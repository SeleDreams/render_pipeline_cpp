# Circular Point Effect

vertex:
    inout: |
        #if !STEREO_MODE
        uniform mat4 p3d_ModelViewMatrix;
        uniform mat4 p3d_ProjectionMatrix;
        uniform float point_radius;
        #endif

    post_transform: |
        #if !STEREO_MODE
        gl_PointSize = point_radius * WINDOW_WIDTH * p3d_ProjectionMatrix[0][0] / (p3d_ModelViewMatrix * p3d_Vertex).y;
        vOutput.normal = vec3((gl_Position.xy / gl_Position.w + 1.0f) * (SCREEN_SIZE / 2.0f), gl_PointSize / 2.0f);
        #endif

geometry:
    defines: |
        #define USE_POINTS_LAYOUT 1

    inout: |
        #if STEREO_MODE
        uniform float point_radius;
        #endif

    post_transform: |
        #if STEREO_MODE
        gl_PointSize = point_radius * WINDOW_WIDTH * MainSceneData.stereo_ProjectionMatrix[layer][0][0] /
            (MainSceneData.stereo_ViewMatrix[layer] * gl_in[0].gl_Position).y;
        vOutput.normal = vec3((gl_Position.xy / gl_Position.w + 1.0f) * (SCREEN_SIZE / 2.0f), gl_PointSize / 2.0f);
        #endif

fragment:
    inout: |
        vec2 circular_points_unit_coord;

    main_begin: |
        circular_points_unit_coord = (gl_FragCoord.xy - vOutput.normal.xy) / vOutput.normal.z;
        const float sphere_radius_square = dot(circular_points_unit_coord, circular_points_unit_coord);
        if (sphere_radius_square > 1.0f) discard;

    texcoord:
        texcoord = fma(circular_points_unit_coord, vec2(0.5f), vec2(0.5f));

    material: |
        m.normal.xz = circular_points_unit_coord;
        m.normal.y = -sqrt(1.0f - dot(circular_points_unit_coord, circular_points_unit_coord));
